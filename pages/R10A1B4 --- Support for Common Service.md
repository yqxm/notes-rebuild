- #+BEGIN_PINNED
  Peterson, L. L., & Davie, B. S. (2022). Computer networks: a systems approach (6th ed.). Morgan Kaufmann.c1.2.4
  #+END_PINNED
- 仅仅将网络视为传输包(*packets*)的工具是对网络问题的简化，更准确的来说，网络是给分布在不同host的应用提供通信方法的工具。这里的核心需求是如何让应用在网络中以更好的方式通信。
- 当两个不同host的应用进行通信的时候，有大量的细节隐藏在传递消息这个过程中。对于这些细节，一种方法是将它们集成在应用中，不过更普遍的是将它们作为通用的服务提供给应用。对于网络设计者来说，识别这些通用服务是一个挑战。做好它可以将网络的复杂性给隐藏起来，解放应用开发者。
- ![../_images/f01-07-9780123850591.png](https://book.systemsapproach.org/_images/f01-07-9780123850591.png){:height 331, :width 456}
	- 直觉上，网络提供给应用级别的进程一系列channel。每一个channel提供了一系列服务。像管道一样一个应用从这边发送信息，另一个应用从管道的另一边获取信息。
	- 像任何其他抽象一样，逻辑上*process-to-process*的channel是在物理上*host-to-host*的channel实现的。这是分层结构的关键，是网络架构的基石。
	- 这里的关键挑战是识别channel要提供哪些功能给应用，比如:
		- 应用是否要求消息送达的保证，或者是不是可以接受消息没有送达？
		- 接收方是不是要以发送的顺序接收消息，或者接收方是不是在意消息是乱序的？
		- 网络是不是需要保证没有第三方监视channel，或者是不是要保证隐私？
	- 网络提供了拥有不同服务的channel，应用根据自己的需求来使用这些channel。
- ## Identify Common Communication Patterns
	- 设计抽象channel需要首先理解有代表性的应用们的通信需求，然后抽取普遍的通信要求(Communication requirements)，最后将满足这些要求的功能融入到网络。
		- 网络最早支持的应用是一些文件传输应用，比如FTP(文件传输协议)和NFS(网络文件系统)。尽管它们是实现细节不同，但它们的远程文件访问都是以一对进程进行的，一个进程请求文件读写，另一个进程满足这个请求。
			- 发出请求读写的是client，支持读写的是server。读文件意味着client发送小的request，而server返回大的response。写文件意味着client发送包含文件的大message，而server返回一个小的response。
		- 数字图书馆是比文件传输更复杂的应用，它还提供了搜索和浏览的功能。不过它的最终目的还是给用户它们请求的文件。
	- 以文件传输应用，数字图书馆和视频应用，视频会议应用为样本，我们决定提供以下两种类型的channel: *request/reply*和*message stream*。
		- *request/reply*被用于文件传输应用和数字图书馆。它可以保证每一个消息都被接收方接收，并且消息只被接收一遍。它还可以保证数据的隐私和完整性，让第三方无法读取或修改数据。
		- *message stream*可以用于网络视频应用和视频会议应用。可以通过参数化的设置让它支持单通道或者双通道的流量和不同的延迟属性。*message stream*可能不需要所有的消息都被发送，因为视频应用自己可以解决这种情况。但*message stream*必须能够保证信息是按顺序传输的。和*request/reply*一样，它也要保证隐私和数据完整型。同时，它还要满足多播的需求。
	- 网络设计者可能倾向于用最少的abstract channel来满足最多的应用。但channel太少的话同样会带来问题，应用开发者可能在任何情况下都只使用这几个channel，即使它们不符合应用的语义。所以网络设计者应该不断的创建新的channel或者给现有的channel新的选项以满足新的应用开发的需求。
	- 同样需要注意的还有“channel的功能是谁提供的”。
		- 在大多数情况下，最容易的方法是将底层网络中的*host-to-host*看作一个*bit pipe*(比特管道)，而高层的通信语义由终端主机提供。这样做的好处是让交换机的工作方式更简单(只包括转发packet)，坏处是终端主机承担了更多的工作。
		- 另外一种做法是将交换机作为功能的提供者，这使得终端可以是一些*dumb*设备(如手机)
- ## Reliable Message Delivery
	- 可靠性是网络需要提供的最重要的功能。需要了解到的是网络并不是在一个完美的环境下工作的，机器可能崩溃和重启，光纤可能被切，数据传输时可能因为电磁干扰导致数据位出错，交换机可能用尽缓存，即使没有这些物理上的错误，管理硬件的软件也有可能包含错误导致有些时候该转发的包消失了。所以网络需要从特定的错误中**恢复**的能力，让应用不用区处理甚至感知到这些错误。
	- 有三种类型需要网络设计者考虑的错误:
		- *bit error*
			- 在link上传输的时候可能发生位错误，即1可能变成0，0可能变成1。有些时候只会有一个位发生错误，更多时候是一串连续的位发生错误。
			- 位错误通常是外部导致的，而且发生的概率很低。即使发生错误，也有检测技术检测能够到并将它修正，如果知道如何修正的话，或者将整个packet丢弃。
		- *packet lost*
			- 数据包丢失的原因可能是位错误无法修正，更多的原因可能是转发的节点没有空间存储packet而被迫丢弃，即发生了“拥塞”。少部分的原因是，处理包转发的软件发生了错误，比如将包错误地转发给了一个节点，导致在接下来的转发中永远没有办法找到最终目标。
			- 这里的挑战在于识别数据包是已经丢失了还是迟到了。
		- *node or link error*
			- 这个错误可能是链路被切，计算机崩溃。原因可能是软件崩溃，电源故障或者一个粗心的铲车操作员。虽然这种错误最后会被修正，但仍会在很长的一段时间对网络产生巨大的影响。处理这类错误的难点在于判断节点是发生了错误还是速度差或者链路是被切断了还是性能差。
- #+BEGIN_TIP
  定义有用的channel需要理解应用的需求和底层技术的使用条件限制。难点在于如何利用这些的技术来满足应用的需要。这个gap被称为*semantic gap*
  #+END_TIP
-